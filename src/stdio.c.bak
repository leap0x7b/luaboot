/*
 * stdio.c
 *
 * Copyright (C) 2021 bzt (bztsrc@gitlab)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * This file is part of the POSIX-UEFI package.
 * @brief Implementing functions which are defined in stdio.h
 *
 */

#include <stdarg.h>
#include <stdint.h>
#include <stddef.h>
#include <stdio.h>
#include <errno.h>
#include <time.h>
#include <luaboot/stdlib.h>
#include <luaboot/string.h>
#include <luaboot/printf.h>
#include <luaboot/e9.h>
#include <luaboot/efi.h>

typedef uint64_t off_t;

typedef struct {
    off_t                   offset;
    EFI_BLOCK_IO          *bio;
} block_file_t;

static EFI_FILE_HANDLE __root_dir = NULL;
static EFI_SERIAL_IO_PROTOCOL *__ser = NULL;
static block_file_t *__blk_devs = NULL;
static size_t __blk_ndevs = 0;
extern time_t __mktime_efi(EFI_TIME *t);
void __stdio_cleanup(void);
void __stdio_seterrno(EFI_STATUS status);
int __remove (const char *__filename, int isdir);
FILE *stdin = (FILE*)-1;
FILE *stdout = (FILE*)-2;
FILE *stderr = (FILE*)-3;

void __stdio_cleanup(void)
{
    if(__blk_devs) {
        free(__blk_devs);
        __blk_devs = NULL;
        __blk_ndevs = 0;
    }
}

void __stdio_seterrno(EFI_STATUS status)
{
    switch((int)(status & 0xffff)) {
        case EFI_WRITE_PROTECTED & 0xffff: errno = EROFS; break;
        case EFI_ACCESS_DENIED & 0xffff: errno = EACCES; break;
        case EFI_VOLUME_FULL & 0xffff: errno = ENOSPC; break;
        case EFI_NOT_FOUND & 0xffff: errno = ENOENT; break;
        case EFI_INVALID_PARAMETER & 0xffff: errno = EINVAL; break;
        default: errno = EIO; break;
    }
}

/*int fstat (FILE *__f, struct stat *__buf)
{
    EFI_GUID infGuid = EFI_FILE_INFO_ID;
    EFI_FILE_INFO info;
    size_t fsiz = (size_t)sizeof(EFI_FILE_INFO);
    EFI_STATUS status;
    size_t i;

    if(!__f || !__buf) {
        errno = EINVAL;
        return -1;
    }
    memset(__buf, 0, sizeof(struct stat));
    if(__f == stdin) {
        __buf->st_mode = S_IREAD | S_IFIFO;
        return 0;
    }
    if(__f == stdout || __f == stderr) {
        __buf->st_mode = S_IWRITE | S_IFIFO;
        return 0;
    }
    if(__ser && __f == (FILE*)__ser) {
        __buf->st_mode = S_IREAD | S_IWRITE | S_IFCHR;
        return 0;
    }
    for(i = 0; i < __blk_ndevs; i++)
        if(__f == (FILE*)__blk_devs[i].bio) {
            __buf->st_mode = S_IREAD | S_IWRITE | S_IFBLK;
            __buf->st_size = (off_t)__blk_devs[i].bio->Media->BlockSize * ((off_t)__blk_devs[i].bio->Media->LastBlock + 1);
            __buf->st_blocks = __blk_devs[i].bio->Media->LastBlock + 1;
            return 0;
        }
    status = __f->GetInfo(__f, &infGuid, &fsiz, &info);
    if(EFI_ERROR(status)) {
        __stdio_seterrno(status);
        return -1;
    }
    __buf->st_mode = S_IREAD |
        (info.Attribute & EFI_FILE_READ_ONLY ? 0 : S_IWRITE) |
        (info.Attribute & EFI_FILE_DIRECTORY ? S_IFDIR : S_IFREG);
    __buf->st_size = (off_t)info.FileSize;
    __buf->st_blocks = (blkcnt_t)info.PhysicalSize;
    __buf->st_atime = __mktime_efi(&info.LastAccessTime);
    __buf->st_mtime = __mktime_efi(&info.ModificationTime);
    __buf->st_ctime = __mktime_efi(&info.CreateTime);
    return 0;
}*/

int fclose (FILE *__stream)
{
    EFI_STATUS status = EFI_SUCCESS;
    size_t i;
    if(!__stream) {
        errno = EINVAL;
        return 0;
    }
    if(__stream == stdin || __stream == stdout || __stream == stderr || (__ser && __stream == (FILE*)__ser)) {
        return 1;
    }
    for(i = 0; i < __blk_ndevs; i++)
        if(__stream == (FILE*)__blk_devs[i].bio)
            return 1;
    status = __stream->Close(__stream);
    free(__stream);
    return !EFI_ERROR(status);
}

int fflush (FILE *__stream)
{
    EFI_STATUS status = EFI_SUCCESS;
    size_t i;
    if(!__stream) {
        errno = EINVAL;
        return 0;
    }
    if(__stream == stdin || __stream == stdout || __stream == stderr || (__ser && __stream == (FILE*)__ser)) {
        return 1;
    }
    for(i = 0; i < __blk_ndevs; i++)
        if(__stream == (FILE*)__blk_devs[i].bio) {
            return 1;
        }
    status = __stream->Flush(__stream);
    return !EFI_ERROR(status);
}

int __remove (const char *__filename, int isdir)
{
    EFI_STATUS status;
    EFI_GUID infGuid = EFI_FILE_INFO_ID;
    EFI_FILE_INFO info;
    size_t fsiz = (size_t)sizeof(EFI_FILE_INFO), i;
    /* little hack to support read and write mode for Delete() and stat() without create mode or checks */
    FILE *f = fopen(__filename, "*");
    if(errno)
        return 1;
    if(!f || f == stdin || f == stdout || f == stderr || (__ser && f == (FILE*)__ser)) {
        errno = EBADF;
        return 1;
    }
    for(i = 0; i < __blk_ndevs; i++)
        if(f == (FILE*)__blk_devs[i].bio) {
            errno = EBADF;
            return 1;
        }
    if(isdir != -1) {
        status = f->GetInfo(f, &infGuid, &fsiz, &info);
        if(EFI_ERROR(status)) goto err;
        if(isdir == 0 && (info.Attribute & EFI_FILE_DIRECTORY)) {
            fclose(f); errno = EISDIR;
            return -1;
        }
        if(isdir == 1 && !(info.Attribute & EFI_FILE_DIRECTORY)) {
            fclose(f); errno = ENOTDIR;
            return -1;
        }
    }
    status = f->Delete(f);
    if(EFI_ERROR(status)) {
err:    __stdio_seterrno(status);
        fclose(f);
        return -1;
    }
    /* no need for fclose(f); */
    free(f);
    return 0;
}

int remove (const char *__filename)
{
    return __remove(__filename, -1);
}

FILE *fopen (const char *__filename, const char *__modes)
{
    FILE *ret;
    EFI_STATUS status;
    EFI_GUID sfsGuid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;
    EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *sfs = NULL;
    EFI_GUID infGuid = EFI_FILE_INFO_ID;
    EFI_FILE_INFO info;
    size_t fsiz = (size_t)sizeof(EFI_FILE_INFO), par, i;
#ifndef UEFI_NO_UTF8
    wchar_t wcname[BUFSIZ];
#endif
    errno = 0;
    if(!__filename || !*__filename || !__modes || (__modes[0] != 'r' && __modes[0] != 'w' && __modes[0] != 'a' &&
      __modes[0] != '*') || (__modes[1] != 0 && __modes[1] != 'd' && __modes[1] != '+')) {
        errno = EINVAL;
        return NULL;
    }
    /* fake some device names. UEFI has no concept of device files */
    if(!strcmp(__filename, "/dev/stdin")) {
        if(__modes[0] == 'w' || __modes[0] == 'a') { errno = EPERM; return NULL; }
        return stdin;
    }
    if(!strcmp(__filename, "/dev/stdout")) {
        if(__modes[0] == 'r') { errno = EPERM; return NULL; }
        return (FILE*)ST->ConsoleOutHandle;
    }
    if(!strcmp(__filename, "/dev/stderr")) {
        if(__modes[0] == 'r') { errno = EPERM; return NULL; }
        return (FILE*)ST->StandardErrorHandle;
    }
    if(!memcmp(__filename, "/dev/serial", 11 * sizeof(char))) {
        par = (size_t)atol(__filename + 11);
        if(!__ser) {
            EFI_GUID serGuid = EFI_SERIAL_IO_PROTOCOL_GUID;
            status = BS->LocateProtocol(&serGuid, NULL, (void**)&__ser);
            if(EFI_ERROR(status) || !__ser) { errno = ENOENT; return NULL; }
        }
        __ser->SetAttributes(__ser, par > 9600 ? par : 115200, 0, 1000, NoParity, 8, OneStopBit);
        return (FILE*)__ser;
    }
    if(!memcmp(__filename, "/dev/disk", 9 * sizeof(char))) {
        par = (size_t)atol(__filename + 9);
        if(!__blk_ndevs) {
            EFI_GUID bioGuid = EFI_BLOCK_IO_PROTOCOL_GUID;
            EFI_HANDLE handles[128];
            size_t handle_size = sizeof(handles);
            status = BS->LocateHandle(ByProtocol, &bioGuid, NULL, &handle_size, (EFI_HANDLE*)&handles);
            if(!EFI_ERROR(status)) {
                handle_size /= (size_t)sizeof(EFI_HANDLE);
                /* workaround a bug in TianoCore, it reports zero size even though the data is in the buffer */
                if(handle_size < 1)
                    handle_size = (size_t)sizeof(handles) / sizeof(EFI_HANDLE);
                __blk_devs = (block_file_t*)malloc(handle_size * sizeof(block_file_t));
                if(__blk_devs) {
                    memset(__blk_devs, 0, handle_size * sizeof(block_file_t));
                    for(i = __blk_ndevs = 0; i < handle_size; i++)
                        if(handles[i] && !EFI_ERROR(BS->HandleProtocol(handles[i], &bioGuid, (void **) &__blk_devs[__blk_ndevs].bio)) &&
                            __blk_devs[__blk_ndevs].bio && __blk_devs[__blk_ndevs].bio->Media &&
                            __blk_devs[__blk_ndevs].bio->Media->BlockSize > 0)
                                __blk_ndevs++;
                } else
                    __blk_ndevs = 0;
            }
        }
        if(__blk_ndevs && par < __blk_ndevs)
            return (FILE*)__blk_devs[par].bio;
        errno = ENOENT;
        return NULL;
    }
    if(!__root_dir && LIP) {
        status = BS->HandleProtocol(LIP->DeviceHandle, &sfsGuid, (void **)&sfs);
        if(!EFI_ERROR(status))
            status = sfs->OpenVolume(sfs, &__root_dir);
    }
    if(!__root_dir) {
        errno = ENODEV;
        return NULL;
    }
    ret = (FILE*)malloc(sizeof(FILE));
    if(!ret) return NULL;
    /* normally write means read,write,create. But for remove (internal '*' mode), we need read,write without create
     * also mode 'w' in POSIX means write-only (without read), but that's not working on certain firmware, we must
     * pass read too. This poses a problem of truncating a write-only file, see issue #26, we have to do that manually */
    mbstowcs((wchar_t*)&wcname, __filename, BUFSIZ - 1);
    status = __root_dir->Open(__root_dir, &ret, (wchar_t*)&wcname,
        __modes[0] == 'w' || __modes[0] == 'a' ? (EFI_FILE_MODE_WRITE | EFI_FILE_MODE_READ | EFI_FILE_MODE_CREATE) :
            EFI_FILE_MODE_READ | (__modes[0] == '*' || __modes[1] == '+' ? EFI_FILE_MODE_WRITE : 0),
        __modes[1] == 'd' ? EFI_FILE_DIRECTORY : 0);
    if(EFI_ERROR(status)) {
err:    __stdio_seterrno(status);
        free(ret); return NULL;
    }
    if(__modes[0] == '*') return ret;
    status = ret->GetInfo(ret, &infGuid, &fsiz, &info);
    if(EFI_ERROR(status)) goto err;
    if(__modes[1] == 'd' && !(info.Attribute & EFI_FILE_DIRECTORY)) {
        ret->Close(ret); free(ret); errno = ENOTDIR; return NULL;
    }
    if(__modes[1] != 'd' && (info.Attribute & EFI_FILE_DIRECTORY)) {
        ret->Close(ret); free(ret); errno = EISDIR; return NULL;
    }
    if(__modes[0] == 'a') fseek(ret, 0, SEEK_END);
    if(__modes[0] == 'w') {
        /* manually truncate file size
         * See https://github.com/tianocore/edk2/blob/master/MdePkg/Library/UefiFileHandleLib/UefiFileHandleLib.c
         * function FileHandleSetSize */
        info.FileSize = 0;
        ret->SetInfo(ret, &infGuid, fsiz, &info);
    }
    return ret;
}

size_t fread (void *__ptr, size_t __size, size_t __n, FILE *__stream)
{
    size_t bs = __size * __n, i, n;
    EFI_STATUS status;
    if(!__ptr || __size < 1 || __n < 1 || !__stream) {
        errno = EINVAL;
        return 0;
    }
    if(__stream == stdin || __stream == stdout || __stream == stderr) {
        errno = ESPIPE;
        return 0;
    }
    if(__ser && __stream == (FILE*)__ser) {
        status = __ser->Read(__ser, &bs, __ptr);
    } else {
        for(i = 0; i < __blk_ndevs; i++)
            if(__stream == (FILE*)__blk_devs[i].bio) {
                n = __blk_devs[i].offset / __blk_devs[i].bio->Media->BlockSize;
                bs = (bs / __blk_devs[i].bio->Media->BlockSize) * __blk_devs[i].bio->Media->BlockSize;
                status = __blk_devs[i].bio->ReadBlocks(__blk_devs[i].bio, __blk_devs[i].bio->Media->MediaId, n, bs, __ptr);
                if(EFI_ERROR(status)) {
                    __stdio_seterrno(status);
                    return 0;
                }
                __blk_devs[i].offset += bs;
                return bs / __size;
            }
        status = __stream->Read(__stream, &bs, __ptr);
    }
    if(EFI_ERROR(status)) {
        __stdio_seterrno(status);
        return 0;
    }
    return bs / __size;
}

size_t fwrite (const void *__ptr, size_t __size, size_t __n, FILE *__stream)
{
    size_t bs = __size * __n, n, i;
    EFI_STATUS status;
    if(!__ptr || __size < 1 || __n < 1 || !__stream) {
        errno = EINVAL;
        return 0;
    }
    if(__stream == stdin || __stream == stdout || __stream == stderr) {
        errno = ESPIPE;
        return 0;
    }
    if(__ser && __stream == (FILE*)__ser) {
        status = __ser->Write(__ser, &bs, (void*)__ptr);
    } else {
        for(i = 0; i < __blk_ndevs; i++)
            if(__stream == (FILE*)__blk_devs[i].bio) {
                n = __blk_devs[i].offset / __blk_devs[i].bio->Media->BlockSize;
                bs = (bs / __blk_devs[i].bio->Media->BlockSize) * __blk_devs[i].bio->Media->BlockSize;
                status = __blk_devs[i].bio->WriteBlocks(__blk_devs[i].bio, __blk_devs[i].bio->Media->MediaId, n, bs, (void*)__ptr);
                if(EFI_ERROR(status)) {
                    __stdio_seterrno(status);
                    return 0;
                }
                __blk_devs[i].offset += bs;
                return bs / __size;
            }
        status = __stream->Write(__stream, &bs, (void *)__ptr);
    }
    if(EFI_ERROR(status)) {
        __stdio_seterrno(status);
        return 0;
    }
    return bs / __size;
}

int fseek (FILE *__stream, long int __off, int __whence)
{
    off_t off = 0;
    EFI_STATUS status;
    EFI_GUID infoGuid = EFI_FILE_INFO_ID;
    EFI_FILE_INFO info;
    size_t fsiz = sizeof(EFI_FILE_INFO), i;
    if(!__stream || (__whence != SEEK_SET && __whence != SEEK_CUR && __whence != SEEK_END)) {
        errno = EINVAL;
        return -1;
    }
    if(__stream == stdin || __stream == stdout || __stream == stderr) {
        errno = ESPIPE;
        return -1;
    }
    if(__ser && __stream == (FILE*)__ser) {
        errno = EBADF;
        return -1;
    }
    for(i = 0; i < __blk_ndevs; i++)
        if(__stream == (FILE*)__blk_devs[i].bio) {
            off = (uint64_t)__blk_devs[i].bio->Media->BlockSize * (uint64_t)__blk_devs[i].bio->Media->LastBlock;
            switch(__whence) {
                case SEEK_END:
                    __blk_devs[i].offset = off + __off;
                    break;
                case SEEK_CUR:
                    __blk_devs[i].offset += __off;
                    break;
                case SEEK_SET:
                    __blk_devs[i].offset = __off;
                    break;
            }
            if(__blk_devs[i].offset < 0) __blk_devs[i].offset = 0;
            if(__blk_devs[i].offset > off) __blk_devs[i].offset = off;
            __blk_devs[i].offset = (__blk_devs[i].offset / __blk_devs[i].bio->Media->BlockSize) *
                __blk_devs[i].bio->Media->BlockSize;
            return 0;
        }
    switch(__whence) {
        case SEEK_END:
            status = __stream->GetInfo(__stream, &infoGuid, &fsiz, &info);
            if(!EFI_ERROR(status)) {
                off = info.FileSize + __off;
                status = __stream->SetPosition(__stream, off);
            }
            break;
        case SEEK_CUR:
            status = __stream->GetPosition(__stream, &off);
            if(!EFI_ERROR(status)) {
                off += __off;
                status = __stream->SetPosition(__stream, off);
            }
            break;
        default:
            status = __stream->SetPosition(__stream, __off);
            break;
    }
    return EFI_ERROR(status) ? -1 : 0;
}

int ftell (FILE *__stream)
{
    int off = 0;
    size_t i;
    EFI_STATUS status;
    if(!__stream) {
        errno = EINVAL;
        return -1;
    }
    if(__stream == stdin || __stream == stdout || __stream == stderr) {
        errno = ESPIPE;
        return -1;
    }
    if(__ser && __stream == (FILE*)__ser) {
        errno = EBADF;
        return -1;
    }
    for(i = 0; i < __blk_ndevs; i++)
        if(__stream == (FILE*)__blk_devs[i].bio) {
            return __blk_devs[i].offset;
        }
    status = __stream->GetPosition(__stream, &off);
    return EFI_ERROR(status) ? -1 : off;
}

int feof (FILE *__stream)
{
    uint64_t off = 0;
    EFI_GUID infGuid = EFI_FILE_INFO_ID;
    EFI_FILE_INFO info;
    size_t fsiz = (size_t)sizeof(EFI_FILE_INFO), i;
    EFI_STATUS status;
    if(!__stream) {
        errno = EINVAL;
        return 0;
    }
    if(__stream == stdin || __stream == stdout || __stream == stderr) {
        errno = ESPIPE;
        return 0;
    }
    if(__ser && __stream == (FILE*)__ser) {
        errno = EBADF;
        return 0;
    }
    for(i = 0; i < __blk_ndevs; i++)
        if(__stream == (FILE*)__blk_devs[i].bio) {
            errno = EBADF;
            return __blk_devs[i].offset == (off_t)__blk_devs[i].bio->Media->BlockSize * (off_t)__blk_devs[i].bio->Media->LastBlock;
        }
    status = __stream->GetPosition(__stream, &off);
    if(EFI_ERROR(status)) {
err:    __stdio_seterrno(status);
        return 1;
    }
    status = __stream->GetInfo(__stream, &infGuid, &fsiz, &info);
    if(EFI_ERROR(status)) goto err;
    __stream->SetPosition(__stream, off);
    return info.FileSize == off;
}

int getc(FILE* stream) {
	errno = 0;
	if (!stream) {
		errno = EINVAL;
		return -1;
	}
	uint8_t buf = 0;
    if (stream == stdin)
        return getchar();
    else {
		intptr_t i = fread(&buf, 1, 1, stream);
		if (i <= 0) return -1;
		return buf;
    }
}

void* fgets(void* s, uint64_t n, FILE* stream) {
	errno = 0;
    uint8_t* data = (uint8_t*)s;
    uint64_t c = 0;
    while (c < n) {
        int chr = getc(stream);
		if (chr < 0) {
			if (c) {
				*data++ = 0;
				return s;
			}
			return NULL;
		}
		if (chr == '\n') {
            *data++ = '\n';
            c++;
            if (c >= n) data--;
            *data++ = 0;
            return s;
        }
        if (chr == '\x7f') {
            // backspace
            if (!c) continue;
            c--;
            *(--data) = 0;
            continue;
        }
        *data++ = chr;
        c++;
    }
    *data++ = 0;
    return s;
}

int vfprintf (FILE *__stream, const char *__format, __builtin_va_list args)
{
    wchar_t dst[BUFSIZ];
    char tmp[BUFSIZ];
    size_t ret, i;
    ret = (size_t)vsnprintf(tmp, BUFSIZ, __format, args);
    ret = mbstowcs(dst, tmp, BUFSIZ - 1);
    if(ret < 1 || !__stream || __stream == stdin) return 0;
    for(i = 0; i < __blk_ndevs; i++)
        if(__stream == (FILE*)__blk_devs[i].bio) {
            errno = EBADF;
            return -1;
        }
    if(__stream == stdout)
        ST->ConOut->OutputString(ST->ConOut, (wchar_t*)&dst);
    else if(__stream == stderr)
        ST->StdErr->OutputString(ST->StdErr, (wchar_t*)&dst);
    else if(__ser && __stream == (FILE*)__ser) {
        wcstombs((char*)&tmp, dst, BUFSIZ - 1);
        __ser->Write(__ser, &ret, (void*)&tmp);
    } else
        __stream->Write(__stream, &ret, (void*)&tmp);
    return (int)ret;
}

int fprintf (FILE *__stream, const char *__format, ...)
{
    int ret;
    __builtin_va_list args;
    __builtin_va_start(args, __format);
    ret = vfprintf(__stream, __format, args);
    __builtin_va_end(args);
    return ret;
}

int getchar_ifany (void)
{
    EFI_INPUT_KEY key = { 0 };
    EFI_STATUS status = ST->ConIn->ReadKeyStroke(ST->ConIn, &key);
    return EFI_ERROR(status) ? 0 : key.UnicodeChar;
}

int getchar (void)
{
    size_t idx;
    BS->WaitForEvent(1, &ST->ConIn->WaitForKey, &idx);
    return getchar_ifany();
}

int putchar (int __c)
{
    wchar_t tmp[2];
    tmp[0] = (wchar_t)__c;
    tmp[1] = 0;
    ST->ConOut->OutputString(ST->ConOut, (__c == L'\n' ? (wchar_t*)L"\r\n" : (wchar_t*)&tmp));
    return (int)tmp[0];
}

void clearerr(FILE *) { e9_printf("todo: clearerr\n"); abort(); }
int ferror(FILE *) { e9_printf("todo: ferror\n"); abort(); }
FILE *freopen(const char *, const char *, FILE *) { e9_printf("todo: freopen\n"); abort(); }
int rename(const char *, const char *) { e9_printf("todo: rename\n"); abort(); }
int setvbuf(FILE*, char*, int, size_t) { e9_printf("todo: setvbuf\n"); abort(); }
FILE *tmpfile(void) { e9_printf("todo: tmpfile\n"); abort(); }
char *tmpnam(char *) { e9_printf("todo: tmpnam\n"); abort(); }
void ungetc(int, FILE *) { e9_printf("todo: ungetc\n"); abort(); }